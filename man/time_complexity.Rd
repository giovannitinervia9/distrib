% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utility_functions.R
\name{time_complexity}
\alias{time_complexity}
\title{Benchmark Time Complexity of \code{distrib} Operations}
\usage{
time_complexity(n, distrib, fun = median, times = 100L, ...)
}
\arguments{
\item{n}{Integer. The sample size (number of observations) to simulate for the benchmark.}

\item{distrib}{An object of class \code{"distrib"}.}

\item{fun}{A function to summarize the vector of timings returned by the benchmark.
Defaults to \code{\link[stats]{median}}.}

\item{times}{Integer. The number of iterations to perform for each benchmark.
Defaults to \code{100L}. Higher values provide more stable estimates but increase execution time.}

\item{...}{Additional arguments passed directly to \code{\link[microbenchmark]{microbenchmark}}
(e.g., \code{control} list).
\strong{Note:} Passing \code{unit} here will NOT affect the returned values,
as \code{microbenchmark} always stores raw timings in nanoseconds.}
}
\value{
A named numeric vector containing the summarized execution times for:
\item{loglik}{The log-likelihood function.}
\item{gradient}{The analytical gradient function.}
\item{hessian}{The analytical Hessian function.}
\strong{The values are always in nanoseconds}, regardless of any \code{unit} argument passed.
}
\description{
Evaluates the computational performance of the core operations (log-likelihood,
gradient, and Hessian) for a given distribution object. This function simulates
data and measures execution time to assess scalability with respect to sample size.
}
\details{
The function performs the following steps:
\enumerate{
\item \strong{Simulation}: Generates random parameters \eqn{\theta} by sampling from a standard normal
distribution and transforming them via the inverse link functions defined in \code{distrib}.
Then, it generates \code{n} observations \eqn{y} using the distribution's random number generator.
\item \strong{Benchmarking}: Measures the execution time of \code{loglik(y, theta)},
\code{gradient(y, theta)}, and \code{hessian(y, theta)} using the \pkg{microbenchmark} package.
\item \strong{Aggregation}: Applies the summary function \code{fun} to the raw timing results.
}
}
\examples{
\dontrun{
d <- gaussian_distrib()
ngrid <- 30
nmin <- 10
nmax <- 10000
n <- round(10^seq(log10(nmin), log10(nmax), l = ngrid))
res <- do.call(rbind, lapply(n, \(n) time_complexity(n, d, times = 20L)))
matplot(n, res, type = "l", lty = 1, lwd = 2, col = c("black", "blue", "red"))
legend("topleft",
  lty = 1, lwd = 2, col = c("black", "blue", "red"),
  legend = c("loglik", "gradient", "hessian")
)
}
}
