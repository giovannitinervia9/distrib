% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/numerical_functions.R
\name{expectation}
\alias{expectation}
\title{Calculate the Expected Value of a Function}
\usage{
expectation(distrib, f, theta, ...)
}
\arguments{
\item{distrib}{An object of class \code{"distrib"}}

\item{f}{A function representing the transformation of the random variable \eqn{y}.
\strong{Signature:} It must accept arguments \code{y}, \code{theta}, and \code{...} (see Details).}

\item{theta}{A named list of parameters for the distribution (e.g., \code{list(mu=10, sigma=2)}).
Vectors inside this list allow computing expectations for multiple distribution parametrizations at once.}

\item{...}{Additional arguments passed directly to the function \code{f}.
\strong{Vectorization:} These arguments are fully vectorized. If vectors are provided, they are recycled
against the parameters in \code{theta} according to standard R recycling rules.}
}
\value{
A numeric vector containing the expected values. The length corresponds to the
maximum length among all vectors in \code{theta} and \code{...}.
}
\description{
Computes the expected value of a given function \eqn{f(y)} with respect to a probability distribution defined by \code{distrib}.
It automatically handles continuous distributions (via numerical integration) and discrete distributions (via series summation).
}
\details{
The function calculates:
\itemize{
\item \eqn{E[f(Y)] = \int_{lb}^{ub} f(y, \theta, \dots) \cdot p(y|\theta) \, dy} (Continuous)
\item \eqn{E[f(Y)] = \sum_{y=lb}^{ub} f(y, \theta, \dots) \cdot P(y|\theta)} (Discrete)
}

\strong{Vectorization:}
The function iterates over the longest vector found among \code{theta} and \code{...}.
For example, if \code{theta$mu} has length 2 and you pass a vector of length 2 to \code{...},
the function computes the expectation for the paired values. If lengths differ, standard R recycling applies.

\strong{Requirements for \code{f}:}
The user-provided function \code{f} must be defined with the signature:
\code{f(y, theta, ...)}
}
\examples{
\dontrun{
distrib <- negbin_distrib()

# Define f accepting y, theta, and extra parameter gamma
f_pow <- function(y, theta, gamma = 1) {
  y^gamma
}

# --- Example 1: Basic usage ---
# Calculate E[y^2] for mu=10
expectation(distrib, f_pow, theta = list(mu = 10, theta = 1), gamma = 2)

# --- Example 2: Vectorization over '...' ---
# Calculate 1st, 2nd, and 3rd raw moments (E[y^1], E[y^2], E[y^3]) simultaneously
# mu is fixed at 10, gamma varies (1, 2, 3)
expectation(distrib, f_pow, theta = list(mu = 10, theta = 1), gamma = c(1, 2, 3))

# --- Example 3: Joint Vectorization ---
# Calculate E[y^1] for mu=10 and E[y^2] for mu=20
expectation(distrib, f_pow,
  theta = list(mu = c(10, 20), theta = 1),
  gamma = c(1, 2)
)
}

}
