% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/numerical_functions.R
\name{series}
\alias{series}
\title{Numerical Summation of Discrete Series}
\usage{
series(f, start, end = Inf, step = 100, tol = 1e-10, maxit = 1e+05)
}
\arguments{
\item{f}{A function taking a vector of integers \code{x} and returning a vector of numeric values.
\strong{Must be vectorized} (able to handle multiple inputs at once).}

\item{start}{Numeric. The starting value of the sequence. Can be finite, \code{Inf}, or \code{-Inf}.}

\item{end}{Numeric. The ending value of the sequence. Can be finite, \code{Inf}, or \code{-Inf}.
Defaults to \code{Inf}.}

\item{step}{Integer. The number of terms to calculate in a single vectorized batch.
Larger values generally improve speed but increase memory usage. Defaults to 100.}

\item{tol}{Numeric. Tolerance threshold for convergence. The series stops when the
sum of the current batch is less than \code{tol}. Defaults to \code{1e-10}.}

\item{maxit}{Integer. Safety limit for the maximum number of batch iterations to prevent
infinite loops in non-convergent series. Defaults to 100,000.}
}
\value{
A numeric scalar representing the calculated sum.
}
\description{
Calculates the sum of a function \code{f(x)} over a sequence of integers from \code{start} to \code{end}.
The function is designed to handle finite sums, one-sided infinite series, and
doubly infinite series (from \code{-Inf} to \code{Inf}) by automatically adapting its summation strategy.
}
\details{
\strong{1. Summation Strategies:}
The function automatically detects the domain topology based on \code{start} and \code{end}:
\itemize{
\item \strong{Forward (Standard):} If \code{start <= end} (e.g., \code{1} to \code{Inf}), it sums \eqn{f(start) + f(start+1) + \dots} directly.
\item \strong{Backward (Reflection):} If \code{start > end} (e.g., \code{-1} to \code{-Inf}), it reflects the domain internally.
It calculates \eqn{\sum f(-x)} effectively iterating forward through the negative numbers.
\item \strong{Doubly Infinite (Folding):} If \code{start == -Inf} and \code{end == Inf}, it uses a "folding" strategy around zero.
It first calculates \eqn{f(0)}, then iterates \eqn{x} from 1 to \eqn{\infty}, summing
\eqn{f(x) + f(-x)} at each step.
}

\strong{2. Vectorization and Convergence:}
The summation is performed in blocks of size \code{step} to leverage R's vectorization capabilities.
For infinite bounds, the function checks for convergence: the loop terminates when the sum of
the current block (size \code{step}) drops below the tolerance threshold \code{tol}.
}
\examples{
# --- Case 1: Standard Convergent Series (Basel Problem) ---
# Sum of 1/x^2 from 1 to Inf => pi^2 / 6
f_basel <- function(x) 1 / x^2
series(f_basel, start = 1, end = Inf)

# --- Case 2: Finite Sum ---
# Sum from 1 to 5
series(f_basel, start = 1, end = 5)

# --- Case 3: Backward Series (Negative Domain) ---
# Sum of 1/x^2 from -1 down to -Inf
series(f_basel, start = -1, end = -Inf)

# --- Case 4: Doubly Infinite Series (Discretized Normal) ---
# Sum of Normal density over all integers Z (-Inf to +Inf)
# Should sum to approximately 1
f_norm <- function(x) dnorm(x)
series(f_norm, start = -Inf, end = Inf)

}
